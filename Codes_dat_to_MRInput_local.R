# This dat_to_MRInput_local function is to convet a TwoSampleMR object to a MendelianRandomization Object.
# Some important MR approaches is available in MendelianRandomization package only, e.g. ivw generalized to correlated SNPs.
# This function is a local version of TwoSampleMR::dat_to_MRInput(), which means you can make the conversion locally.
# This feature is quite important when we aimed to include an LD matrix to be calculated from the other reference genome than 1K Genome.
# When we want to run many times such conversion, it's also useful. 

if(!require(TwoSampleMR)){install.packages("TwoSampleMR")}
if(!require(MendelianRandomization)){install.packages("MendelianRandommization")}
if(!require(ieugwasr)){install.packages("ieugwasr")}
if(!require(remotes)){install.packages("remotes")}
if(!require(genetics.binaRies)){remotes::install_github("MRCIEU/genetics.binaRies")}

dat_to_MRInput_local = function(dat, get_correlations=FALSE, pop="EUR", path = NULL)
{
  # plyr::dlply splits the data frame into several subsets and applies the function on each subset 
  # .data is the data frame to be processed
  # .variables is the column names by which the data frame to be split by row; 
  # therefore data frame with multiple exposures/outcomes will be split and processed seperately 
  # .fun is the function to be applied to each subset of the data frame
  out = plyr::dlply(.data = dat, .variables = c("exposure", "outcome"), .fun = function(x) 
    {
    x = plyr::mutate(x)
    message("Converting:")
    message(" - exposure: ", x$exposure[1])
    message(" - outcome: ", x$outcome[1])
    if(get_correlations)
    {
      message(" - obtaining LD matrix")
      # Check whether the path to reference genome is provided
      if(is.null(path)){stop("Please Provide The Path To The Reference Genome")}
      ### Obtain ld matrix
      ### ieugwasr::ld_matrix generates a .bim file by extracting the SNPs from the reference genome.
      ### order of SNPs in the .bim file for extracted SNPs aligns with the order in the reference genome .bim file.
      ### ieugwasr::ld_matrix then calculates the ld matrix from the reference genome for the extracted SNPs.
      ### Please refer to the source code at https://github.com/MRCIEU/ieugwasr/blob/master/R/ld_matrix.R for more details of function ld_matrix.
      ld = ieugwasr::ld_matrix(unique(x$SNP), 
                               plink_bin = genetics.binaRies::get_plink_binary(),
                               bfile = paste0(path, pop))
      # Format the ld matrix
      ### We find sometimes Allele T can be recognized as TRUE when setting the rownames. 
      ### So we substitute TRUE with T if TRUE value really exists.
      rownames(ld) = sub("TRUE", "T", rownames(ld))
      colnames(ld) = sub("TRUE", "T", colnames(ld))
      ### Since the ld matrix is generated by plink from the reference genome.
      ### The order of the SNPs aligns with the order in the reference genome, not always consistent as the GWAS summary.
      ### So we order the ld matrix and the GWAS summary by the SNP name to make them consistent.
      ld = ld[order(rownames(ld)), order(colnames(ld))]
      x = x[order(x$SNP), ]
      # Harmonise the ld matrix to the GWAS summary data
      ### TwoSampleMR::harmonise_ld_dat ensure the effect allele in GWAS summary consistent with the reference allele (A0) in ld matrix.
      ### It also ensures the non-effect allele consistent with the other allele (A1) in ld matrix.
      ### The beta in GWAS summary will be updated to be negative beta if the effect allele matches to the A1.
      ### Please refer to the source code at https://github.com/MRCIEU/TwoSampleMR/blob/master/R/other_formats.R#L82 for more information.
      out = harmonise_ld_dat(x, ld)
      if(is.null(out)){return(NULL)}
      x = out$x
      ld = out$ld
      # Format the data into a MendelianRandomization object
      MendelianRandomization::mr_input(
        bx = x$beta.exposure,
        bxse = x$se.exposure,
        by = x$beta.outcome,
        byse = x$se.outcome,
        exposure = x$exposure[1],
        outcome = x$outcome[1],
        snps = x$SNP,
        effect_allele = x$effect_allele.exposure,
        other_allele = x$other_allele.exposure,
        eaf = x$eaf.exposure,
        correlation = ld
      )
    } else {
      MendelianRandomization::mr_input(
        bx = x$beta.exposure,
        bxse = x$se.exposure,
        by = x$beta.outcome,
        byse = x$se.outcome,
        exposure = x$exposure[1],
        outcome = x$outcome[1],
        snps = x$SNP,
        effect_allele=x$effect_allele.exposure,
        other_allele=x$other_allele.exposure,
        eaf = x$eaf.exposure
      )
    }
  })
  return(out)
}
